1. The time complexity for search/insert would be log base 2 (10000) = 13.29. This means, that in the worse case it would take 13.29 steps/comparisons to find or inset an element if the tree is perfectly balanced. Or best case it would be log base 3(10000) = 8.383 comparisons. As this data set is larger, the time complexity for it is most likely larger.
2. The RedBlackTree's performance is still efficient even with a larger data set due to the logarithmic height and its property to ensure consistent operations. 
3. In my code I used a RedBlackTree, this data set maintains balance by using a set of rules or color properties to ensure of this. In this tree, the design makes sure there is no two red nodes, maintaining equal black heights on each tier. These rules make sure the tree maintains and restricts its hight in the range of x(log n). After various insertions to the tree, the tree rotates and recolors to maintain the balance, which is crutial to large data sets. 
<img width="1278" alt="Screenshot 2024-11-17 at 10 15 11â€¯PM" src="https://github.com/user-attachments/assets/1e8eea6c-e5b6-4493-b9b7-28b1b2282a6a">
